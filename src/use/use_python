#!/bin/bash

use_python() {

  local version=${1:--} # - to read from .pvmrc
  local root=${2:--}    # - to use pwd

  if [ "$version" = "-" ]; then
    version=""
  fi

  if [ "$root" = "-" ]; then
    root=""
  fi

  if [ -z "$root" ]; then
    root=$PWD
  fi

  pushd "$root" >/dev/null || return 1

  watch_file pyproject.toml
  watch_file setup.py
  watch_file setup.cfg

  if [ ! -f pyproject.toml ] && [ ! -f setup.py ] && [ ! -f setup.cfg ]; then
    watch_file requirements.txt
  fi

  _use_python "$version"
  local code=$?

  popd >/dev/null || return 1
  return "$code"

}

_use_python() {

  local version=$1
  local py

  version=$(_get_requested_python_version "$version") || return 1

  _activate_pyenv || return 1
  py=$(_activate_python "$version") || return 1
  _activate_venv "$py" || return 1
  _install_python_dependencies || return 0

}

_get_requested_python_version() {

  local version=${1:-}

  if [ -n "$version" ]; then
    echo "$version"
    return 0
  fi

  local rc

  if rc=$(find_up .pvmrc); then
    cat "$rc" || return 1
    return 0
  fi

  log_error "no .pvmrc file found"
  return 1

}

# pyenv
# --------------------------------------------------------------------------------------------------

_activate_pyenv() {

  if [ "$(type -t pyenv)" = "function" ]; then
    return 0
  fi

  if [ -z "$PYENV_ROOT" ]; then
    export PYENV_ROOT=~/.pyenv
  fi

  if [[ $PATH != *"$PYENV_ROOT/bin:"* ]]; then
    export PATH=$PYENV_ROOT/bin:$PATH
  fi

  if ! command -v pyenv &>/dev/null; then
    _install_pyenv || return 1
  fi

  local initializer
  initializer=$(pyenv init -) || return 1

  eval "$initializer" || return 1

}

_install_pyenv() {

  log_info "installing pyenv"
  curl -s https://pyenv.run | bash || return 1

}

_upgrade_pyenv() {

  log_info "upgrading pyenv"

  local root
  root=$(pyenv root) || return 1

  (
    cd "$root" || return 1
    git pull 1>/dev/null || return 1
  )

}

# python
# --------------------------------------------------------------------------------------------------

_activate_python() {

  local version=$1

  local py

  if ! py=$(_get_python_executable "$version"); then

    _upgrade_pyenv || return 1
    _install_python "$version" || return 1
    py=$(_get_python_executable "$version") || return 1

  fi

  echo "$py"

}

_get_python_executable() {

  local version=$1

  local prefix

  if ! prefix=$(pyenv prefix "$version" 2>/dev/null); then
    return 1
  fi

  echo "${prefix}/bin/python"

}

_install_python() {

  local version=$1

  log_info "installing python"

  (

    export PYTHON_CONFIGURE_OPTS="--enable-optimizations --with-lto"
    export PYTHON_CFLAGS="-march=native -mtune=native"

    pyenv install --skip-existing "$version" 1>/dev/null || return 1

  )

}

# venv
# --------------------------------------------------------------------------------------------------

_activate_venv() {

  local py=$1

  # activate

  unset PYTHONHOME
  export VIRTUAL_ENV=$PWD/.venv

  local relpath
  relpath=$(user_rel_path "$VIRTUAL_ENV")

  _create_venv "$py" || return 1

  PATH=$VIRTUAL_ENV/bin:$PATH
  export PATH

  # verify

  local actual_version
  actual_version=$(python -V)

  local expected_version
  expected_version=$("$py" -V)

  if [ "$actual_version" != "$expected_version" ]; then
    log_warn \
      ".envrc requires ${expected_version}" \
      "but existing virtual environment provides ${actual_version}"
  fi

  # upgrade pip

  pip install \
    --require-virtualenv \
    --no-python-version-warning \
    --upgrade \
    pip \
    1>/dev/null ||
    log_error "failed to upgrade pip in $relpath"

}

_create_venv() {

  local py=$1
  local path=${2:-$VIRTUAL_ENV}

  if [ ! -d "$VIRTUAL_ENV" ]; then

    local relpath
    relpath=$(user_rel_path "$path")

    log_info "creating venv in $path"
    "$py" -m venv "$path" || return 1

  fi

}

# deps
# --------------------------------------------------------------------------------------------------

_install_python_dependencies() {

  if [ -f pyproject.toml ] || [ -f setup.py ] || [ -f setup.cfg ]; then

    _handle_install_python_dependencies project \
      --editable \
      ".[dev]" || return 1

  elif [ -f requirements.txt ]; then

    _handle_install_python_dependencies requirements.txt \
      --requirement requirements.txt || return 1

  fi

}

_handle_install_python_dependencies() {

  local type=$1
  shift

  local code

  log_info "restoring $type dependencies"

  _pip_install "$@"
  code=$?

  if [ "$code" != 0 ]; then
    log_error "failed to restore $type dependencies"
    return 1
  fi

  _update_requirements
  code=$?

  if [ "$code" != 0 ]; then
    log_error "failed to update requirements.txt"
    return 1
  fi

}

_pip_install() {

  pip install \
    --require-virtualenv \
    --disable-pip-version-check \
    --no-python-version-warning \
    "$@" \
    1>/dev/null || return 1

}

_update_requirements() {

  pip freeze \
    --exclude-editable \
    >requirements.txt || return 1

}
